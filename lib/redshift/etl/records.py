"""
Subclasses of FirehoseDeliveryRecord are generated by the `RedshiftPublishingExporter` to capture point-in-time
snapshots of the game's entities' tag states. In combination with the Table Metadata from the `models` module,
each record is able to serialize itself as a '|' delimited string which can then be batched up and sent to Firehose.
"""
import copy
import json
from datetime import datetime
from hearthstone.enums import GameTag, BlockType, Step, CardType, BnetRegion
from hearthstone import entities, cardxml
from .models import metadata
from .firehose import FirehoseOutput

_CARD_DATA_CACHE = {}


def card_db():
	if "db" not in _CARD_DATA_CACHE:
		db, _ = cardxml.load()
		_CARD_DATA_CACHE["db"] = db
	return _CARD_DATA_CACHE["db"]


# This is how block.id PK values are generated:
# (10^12 * block_sequence_num) + game_id
def to_block_id(block_sequence_num, game_id):
	return (10**12 * int(block_sequence_num)) + int(game_id)


class FirehoseDeliveryRecord(object):
	"""
	A Generic baseclass for representing Redshift rows to be delivered via Firehose. Each subclass must meet two
	 criteria:

	 1) It must define a REDSHIFT_TABLE attribute which matches the name of a Redshift table.
	 2) For each column in that table it must define a `_col_<COLUMN_NAME>` attribute which contains the value for the column.

	Due to the width of the entity_state table, if the columns `info` dict contains a GameTag value, then the entity's
	tag value will be used if one is found.
	"""
	REDSHIFT_TABLE = "SUPPLIED_BY_SUBCLASSES"

	@classmethod
	def get_firehose_output(cls):
		return FirehoseOutput(cls.firehose_stream_name())

	@classmethod
	def firehose_stream_name(cls):
		template = "hsreplaynet_kinesis_firehose_%s_stream"
		return template % cls.REDSHIFT_TABLE

	def redshift_table(self):
		if self.REDSHIFT_TABLE in metadata.tables:
			return metadata.tables[self.REDSHIFT_TABLE]
		else:
			return None

	def __init__(self):
		self._game_info_is_set = False

	def to_record(self):
		"""Produce a string in the Firehose expected format"""
		if not self._game_info_is_set:
			raise ValueError("Must call set_game_info(...) before calling to_record()")

		values = []
		EMPTY_VAL = ""

		for col in self.redshift_table().columns:
			val = None

			if hasattr(self, "_col_" + col.name):
				val = getattr(self, "_col_" + col.name)
			elif 'tag' in col.info and hasattr(self, "_tags_snapshot"):
				game_tag = col.info['tag']
				if game_tag in self._tags_snapshot:
					val = self._tags_snapshot[game_tag]
			else:
				raise ValueError("No column renderer found for column: %s" % col.name)

			if val is not None:
				if self._is_type_compatible(col, val):

					if issubclass(col.type.python_type, datetime):
						redshift_expected_format = "%Y-%m-%d %H:%M:%S"
						str_val = val.strftime(redshift_expected_format)
					elif issubclass(col.type.python_type, bool):
						str_val = str(bool(val))
					else:
						str_val = str(val)

					values.append(str_val)
				else:
					msg = "Column: %s - value %s is not compatible with column type %s"
					raise ValueError(msg % (col.name, val, col.type.python_type))
			elif col.default:
				values.append(str(col.default.arg))
			elif col.nullable:
				values.append(EMPTY_VAL)
			else:
				raise ValueError("NOT NULL Columm %s does not have a value" % col.name)

		return "|".join(values)

	def _is_type_compatible(self, col, val):
		if col.type.python_type == bool and val in (0, 1):
			return True
		return isinstance(val, col.type.python_type)

	def set_game_info(self, game_info):
		# This dictionary contains required and optional data which Redshift can store, but which is not
		# Serialized directly into the replay XML file itself.
		self._game_info_is_set = True
		self._game_info = game_info

		# game_id is our DISTKEY and also required to convert a block_sequence_nums into block.id values
		# game_date is used as our SORTKEY
		# We define them here as a convenience to be shared by the subclasses.
		self._col_game_id = game_info["game_id"]
		self._col_game_date = game_info["game_date"]

	def _get_info_info_val(self, key):
		if key in self._game_info:
			return self._game_info[key]
		else:
			return None

	def _discover_dbf_id_for_entity(self, entity):
		if entity:
			dbf_id = None
			# Check for Shifter Zerus
			if GameTag.TRANSFORMED_FROM_CARD in entity.tags:
				dbf_id = entity.tags[GameTag.TRANSFORMED_FROM_CARD]

			if hasattr(entity, "card_id") and entity.card_id:
				dbf_id = card_db()[entity.card_id].dbf_id

			return dbf_id if dbf_id else None
		else:
			return None

	def _discover_card_xml_for_entity(self, entity):
		if hasattr(entity, "card_id") and entity.card_id:
			return card_db()[entity.card_id]


class OptionsRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "options"

	def __init__(
			self,
			game,
			options_block_id,
			options_index,
			option_type,
			option_entity,
			suboption_index,
			suboption_entity,
			target_index,
			target_entity,
			is_sent,
			sent_position,
			sent_suboption,
			sent_target
	):
		super(OptionsRecord, self).__init__()
		self._game = game
		self._col_options_block_id = options_block_id
		self._col_option_index = options_index
		self._col_option_type = option_type
		self._col_option_entity_id = option_entity
		self._col_suboption_index = suboption_index
		self._col_suboption_entity_id = suboption_entity
		self._col_target_index = target_index
		self._col_target_entity_id = target_entity
		self._col_sent = is_sent
		self._col_sent_position = sent_position
		self._col_sent_suboption = sent_suboption
		self._col_sent_target = sent_target
		self._col_player_id = self._game.current_player.player_id
		self._col_turn = self._game.tags.get(GameTag.TURN, 0)
		self._col_step = self._game.tags.get(GameTag.STEP, 0)

	@property
	def _col_player_final_state(self):
		if self._col_player_id:
			player = self._game.get_player(self._col_player_id)
			return player.tags[GameTag.PLAYSTATE]
		else:
			return None

	@property
	def _col_option_entity_dbf_id(self):
		entity = self._game.find_entity_by_id(self._col_option_entity_id)
		return self._discover_dbf_id_for_entity(entity)

	@property
	def _col_suboption_entity_dbf_id(self):
		if self._col_suboption_entity_id:
			entity = self._game.find_entity_by_id(self._col_suboption_entity_id)
			return self._discover_dbf_id_for_entity(entity)
		else:
			return None

	@property
	def _col_target_entity_dbf_id(self):
		if self._col_target_entity_id:
			entity = self._game.find_entity_by_id(self._col_target_entity_id)
			return self._discover_dbf_id_for_entity(entity)
		else:
			return None


class ChoicesRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "choices"

	def __init__(self, game, block, packet, choice_entity_id):
		super(ChoicesRecord, self).__init__()
		self._game = game
		self._block = block
		self._packet = packet
		self._col_player_entity_id = self._packet.entity
		self._col_choices_block_id = self._packet.id
		self._col_choice_type = self._packet.type
		self._col_entity_id = choice_entity_id
		self._col_chosen = False

	@property
	def _col_block_id(self):
		return to_block_id(self._block.block_sequence_num, self._col_game_id)

	@property
	def _col_entity_dbf_id(self):
		entity = self._game.find_entity_by_id(self._col_entity_id)
		return self._discover_dbf_id_for_entity(entity)

	@property
	def _col_source_entity_id(self):
		source = self._packet.source
		return int(source) if source else source

	@property
	def _col_source_entity_dbf_id(self):
		entity = self._game.find_entity_by_id(self._packet.source)
		return self._discover_dbf_id_for_entity(entity)


class PlayerRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "player"

	def __init__(self, game, player_packet):
		super(PlayerRecord, self).__init__()
		self._game = game
		self._player_packet = player_packet
		self._col_player_id = self._player_packet.player_id
		self._col_entity_id = self._player_packet.entity
		self._col_account_lo = self._player_packet.lo

	@property
	def _col_deck_id(self):
		return self._get_key_from_player_info("deck_id")

	@property
	def _col_archetype_id(self):
		return self._get_key_from_player_info("archetype_id")

	@property
	def _col_deck_list(self):
		return self._get_key_from_player_info("deck_list")

	@property
	def _col_final_state(self):
		player = self._game.get_player(self._player_packet.player_id)
		return player.tags[GameTag.PLAYSTATE]

	@property
	def _col_region(self):
		if self._col_is_ai:
			return BnetRegion.REGION_UNKNOWN.value
		else:
			account_hi = self._player_packet.hi
			region = BnetRegion.from_account_hi(int(account_hi))
			return region.value

	@property
	def _col_rank(self):
		rank = self._get_key_from_player_info("rank")
		return int(rank) if rank else rank

	@property
	def _col_legend_rank(self):
		legend_rank = self._get_key_from_player_info("legend_rank")
		return int(legend_rank) if legend_rank else legend_rank

	@property
	def _col_player_class(self):
		player = self._game.get_player(self._player_packet.player_id)
		if player.starting_hero:
			return card_db()[player.starting_hero.card_id].card_class.value
		return None

	@property
	def _col_is_first(self):
		return self._game.first_player.player_id == self._player_packet.player_id

	@property
	def _col_is_ai(self):
		player = self._game.get_player(self._player_packet.player_id)
		return player.is_ai

	@property
	def _col_options_visible(self):
		if self._get_key_from_player_info("options_visible"):
			options_visible = self._get_key_from_player_info("options_visible")
			return bool(options_visible) if options_visible else options_visible
		else:
			return False

	@property
	def _col_full_deck_known(self):
		full_deck_known = self._get_key_from_player_info("full_deck_known")
		return bool(full_deck_known) if full_deck_known else full_deck_known

	@property
	def _col_starting_hero_dbf_id(self):
		player = self._game.get_player(self._player_packet.player_id)
		if player.starting_hero:
			return card_db()[player.starting_hero.card_id].dbf_id
		return None

	def _get_key_from_player_info(self, key):
		if "players" in self._game_info:
			players_data = self._game_info["players"]
			this_player_id = str(self._player_packet.player_id)
			if this_player_id in players_data:
				this_player_data = players_data[this_player_id]
				if key in this_player_data:
					return this_player_data[key]
		return None


class GameRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "game"

	def __init__(self, game, game_packet):
		super(GameRecord, self).__init__()
		self._game = game
		self._game_packet = game_packet

	@property
	def _col_id(self):
		return self._col_game_id

	@property
	def _col_match_start(self):
		if "match_start" in self._game_info:
			return self._game_info["match_start"]
		else:
			return None

	@property
	def _col_game_type(self):
		return self._get_info_info_val("game_type")

	@property
	def _col_region(self):
		return self._get_info_info_val("region")

	@property
	def _col_num_turns(self):
		return int(self._game.tags.get(GameTag.TURN))

	@property
	def _col_game_length_seconds(self):
		return int(self._get_info_info_val("game_length_seconds"))

	@property
	def _col_scenario_id(self):
		scenario_id = self._get_info_info_val("scenario_id")
		return int(scenario_id) if scenario_id else scenario_id

	@property
	def _col_ladder_season(self):
		ladder_season = self._get_info_info_val("ladder_season")
		return int(ladder_season) if ladder_season else ladder_season

	@property
	def _col_brawl_season(self):
		brawl_season = self._get_info_info_val("brawl_season")
		return int(brawl_season) if brawl_season else brawl_season


class BlockInfoRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "block_info"

	def __init__(self, game, block, packet, info_entity_id):
		super(BlockInfoRecord, self).__init__()
		self._game = game
		self._containing_block = block
		self._packet = packet
		self._col_meta_data_type = self._packet.meta
		self._col_info_entity_id = info_entity_id
		self._col_data = self._packet.data

	@property
	def _col_block_id(self):
		return to_block_id(self._containing_block.block_sequence_num, self._col_game_id)

	@property
	def _col_info_entity_dbf_id(self):
		info_entity = self._game.find_entity_by_id(self._col_info_entity_id)
		return self._discover_dbf_id_for_entity(info_entity)


def is_death_block(game, block):
	return block.type == BlockType.DEATHS


def is_card_block(game, block):
	entity = game.find_entity_by_id(block.entity)
	is_card_entity = isinstance(entity, entities.Card)
	return is_card_entity


def is_begin_mulligan_block(game, block):
	entity = game.find_entity_by_id(block.entity)
	if GameTag.STEP in game.tags:
		is_begin_mulligan = game.tags[GameTag.STEP] == Step.BEGIN_MULLIGAN
		is_game_entity = isinstance(entity, entities.Game)
		return is_begin_mulligan and is_game_entity
	else:
		return False


def is_player_main_start(game, block):
	entity = game.find_entity_by_id(block.entity)
	if GameTag.STEP in game.tags:
		is_main_start = game.tags[GameTag.STEP] == Step.MAIN_START
		is_player_entity = isinstance(entity, entities.Player)
		return is_main_start and is_player_entity
	else:
		return False


class BlockRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "block"

	# These are each predicate functions used by the exporter which take a GameEntity and a Block packet
	# If any of them return True then we generate a BlockRecord for the packet
	BLOCK_ELIGABILITY_PREDICATES = [
		is_death_block,
		is_card_block,
		is_begin_mulligan_block,
		is_player_main_start,
	]

	def __init__(self, game, block, parent_block=None):
		super(BlockRecord, self).__init__()
		self._game = game
		self._block = block
		self._col_target_entity_id = self._block.target
		self._col_block_type = self._block.type

		self._parent_block = parent_block
		self._col_turn = game.tags[GameTag.TURN]
		self._col_step = game.tags.get(GameTag.STEP, 0)
		self._block_entity = game.find_entity_by_id(block.entity)
		self._col_entity_id = self._block_entity.id

		# We must capture the entity's controller immediately, since it can change.
		if GameTag.CONTROLLER in self._block_entity.tags:
			self._col_entity_player_id = self._block_entity.tags[GameTag.CONTROLLER]
		else:
			self._col_entity_player_id = None

	@property
	def _col_id(self):
		return to_block_id(self._block.block_sequence_num, self._col_game_id)

	@property
	def _col_entity_dbf_id(self):
		return self._discover_dbf_id_for_entity(self._block_entity)

	@property
	def _col_parent_id(self):
		if self._parent_block:
			return to_block_id(self._parent_block.block_sequence_num, self._col_game_id)
		else:
			return None

	@property
	def _col_target_entity_dbf_id(self):
		if self._block.target:
			target_entity = self._game.find_entity_by_id(self._block.target)
			return self._discover_dbf_id_for_entity(target_entity)
		return None


def filter_game_entity(game, entity, block, is_before_block=True):
	if GameTag.CARDTYPE in entity.tags:
		return entity.tags[GameTag.CARDTYPE] == CardType.GAME
	else:
		return False


def filter_player_from_main_start(game, entity, block, is_before_block=True):
	is_trigger_block = block.type == BlockType.TRIGGER
	is_main_start = game.tags.get(GameTag.STEP, 0) == Step.MAIN_START
	if GameTag.CARDTYPE in entity.tags:
		is_player = entity.tags[GameTag.CARDTYPE] == CardType.PLAYER
		# We only want to capture the drawn card, no reason to snapshot the player
		return is_trigger_block and is_main_start and is_player
	else:
		return False


def filter_player_from_before_blocks(game, entity, block, is_before_block=True):
	# For PLAY, ATTACK, and DEATHS blocks, we only need the after_block entity_state
	# Since there is nothing interesting to delta between the before & after
	if is_before_block and GameTag.CARDTYPE in entity.tags:
		is_player = entity.tags[GameTag.CARDTYPE] == CardType.PLAYER
		qualifying_blocks = (BlockType.PLAY, BlockType.ATTACK, BlockType.DEATHS)
		is_qualifying_block = block.type in qualifying_blocks
		return is_player and is_qualifying_block
	else:
		return False


class EntityStateRecord(FirehoseDeliveryRecord):
	REDSHIFT_TABLE = "entity_state"

	# The entity_state table is the largest table in Redshift.
	# It also contains duplicative data since it journals each entity's state block-by-block as the game progresses.
	# These filter predicate functions are used by the exporter to intelligently slim down the volume
	# of records produced to only the subset which are relevant for game analysis and statistics. They each take:
	# 1) The GameEntity
	# 2) The Entity under consideration
	# 3) The Block under consideration
	# 4) Whether these are the before_block or after_block entity_state records.
	ENTITY_STATE_FILTERING_PREDICATES = [
		filter_game_entity,
		filter_player_from_main_start,
		filter_player_from_before_blocks,
	]

	def __init__(
		self,
		game,
		entity,
		before_block_seq_num=None,
		after_block_seq_num=None,
	):
		super(EntityStateRecord, self).__init__()
		self._game = game
		self._entity = entity
		self._col_entity_id = self._entity.id

		if hasattr(self._entity, "entered_zone_on"):
			self._col_entered_zone_on = self._entity.entered_zone_on
		else:
			# Is not set on player entities
			self._col_entered_zone_on = None

		self._before_block_seq_num = before_block_seq_num
		self._after_block_seq_num = after_block_seq_num

		self._col_entity_in_initial_entities = entity in game.initial_entities
		self._col_turn = game.tags[GameTag.TURN]
		self._col_step = game.tags.get(GameTag.STEP, 0)
		# NOTE: We immediately copy the tags to preserve a point-in-time snapshot of their values
		self._tags_snapshot = copy.copy(entity.tags)
		# This is a playerID not an entityID
		self._col_controller_id = None
		self._controller_final_state = None

		if GameTag.CONTROLLER in entity.tags:
			self._col_controller_id = entity.tags[GameTag.CONTROLLER]

	def __repr__(self):
		tmpl = "Turn: %s Step: %s Entity: %s Name: %s Controller: %s Before_Block: %s After_Block: %s"
		return tmpl % (
			self._col_turn,
			self.step_name,
			self._col_entity_id,
			self.entity_name,
			self._col_controller_id,
			self._before_block_seq_num,
			self._after_block_seq_num
		)

	@property
	def pretty_tags(self):
		return {GameTag(tag).name: val for tag, val in self._tags_snapshot.items()}

	@property
	def entity_name(self):
		card_xml = self._discover_card_xml_for_entity(self._entity)
		if card_xml:
			return card_xml.name

	@property
	def step_name(self):
		return Step(self._col_step).name

	@property
	def _col_tags(self):
		# Tags are stored in a VARCHAR field and can be accessed like this:
		# json_extract_path_text('{"47": 8}', '47')
		# To save space we remove every tag from the overflow tags that has its own column
		overflow_tags = copy.copy(self._tags_snapshot)

		for col in self.redshift_table().columns:
			if 'tag' in col.info:
				game_tag = col.info['tag']
				if game_tag in overflow_tags:
					del overflow_tags[game_tag]

		# separators=(',', ':') creates compact JSON encoding
		return json.dumps(overflow_tags, separators=(',', ':'))

	@property
	def _col_attached_dbf_id(self):
		return self._resolve_entity_referencing_tag(GameTag.ATTACHED)

	@property
	def _col_last_affected_by_dbf_id(self):
		return self._resolve_entity_referencing_tag(GameTag.LAST_AFFECTED_BY)

	def _resolve_entity_referencing_tag(self, tag):
		if tag in self._tags_snapshot:
			referenced_entity_id = self._tags_snapshot[tag]
			referenced_entity = self._game.find_entity_by_id(referenced_entity_id)
			return self._discover_dbf_id_for_entity(referenced_entity)
		else:
			return None

	@property
	def _col_controller_final_state(self):
		if self._col_controller_id:
			player = self._game.get_player(self._col_controller_id)
			return player.tags[GameTag.PLAYSTATE]
		else:
			return None

	@property
	def _col_after_block_id(self):
		if self._after_block_seq_num:
			return to_block_id(self._after_block_seq_num, self._col_game_id)
		else:
			return None

	@property
	def _col_before_block_id(self):
		if self._before_block_seq_num:
			return to_block_id(self._before_block_seq_num, self._col_game_id)
		else:
			return None

	@property
	def _col_dbf_id(self):
		return self._discover_dbf_id_for_entity(self._entity)

	@property
	def _col_class(self):
		# This tag is not always set, but it's valuable to have populated.
		if hasattr(self._entity, "card_id") and self._entity.card_id:
			return card_db()[self._entity.card_id].card_class.value
		else:
			return None

	@property
	def _col_card_set(self):
		# This tag is not always set, but it's valuable to have populated.
		if hasattr(self._entity, "card_id") and self._entity.card_id:
			return card_db()[self._entity.card_id].card_set.value
		else:
			return None
